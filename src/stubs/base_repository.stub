<?php

namespace App\Repositories\Shared;

use App\DTOs\Shared\IndexQueryDTO;
use App\Repositories\Contracts\IBaseRepository;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Support\Arr;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

abstract class BaseRepository implements IBaseRepository
{
    public function __construct(protected Model $model) {}

    /**
     * Se true: quando vier filtro/sort/where inválido, lança exception.
     * Se false: ignora silenciosamente.
     */
    protected bool $strictQuery = false;

    /**
     *  Configurável:
     * Se true: aplica lockForUpdate() no update.
     * Se false: update normal (melhor concorrência/performance).
     */
    protected bool $useLockForUpdateOnUpdate = false;

    public function query(): Builder
    {
        /** @var Builder $q */
        $q = $this->model->newQuery();
        return $q;
    }

    public function with(array $relations): Builder
    {
        $q = $this->query();

        if (!empty($relations)) {
            $allowed = $this->allowedRelations($relations);
            $rels = array_values(array_intersect($relations, $allowed));
            if ($rels) {
                $q->with($rels);
            }
        }

        return $q;
    }

    public function getAll(IndexQueryDTO $dto): LengthAwarePaginator
    {
        $q = $this->query();

        // WITH
        if (!empty($dto->with)) {
            $allowed = $this->allowedRelations($dto->with);
            $rels = array_values(array_intersect($dto->with, $allowed));
            if ($rels) {
                $q->with($rels);
            }
        }

        // FILTERS (valida colunas antes)
        if (!empty($dto->filters)) {
            $q = $this->applyFilters($q, $dto->filters);
        }

        // SORT (valida coluna)
        if (!empty($dto->sortBy)) {
            $sortBy = $this->resolveSortColumn($dto->sortBy);
            if ($sortBy !== null) {
                $q->orderBy($sortBy, $dto->sortDir);
            }
        }

        $paginator = $q->paginate($dto->perPage, ['*'], 'page', $dto->page);

        return $paginator->appends($this->buildAppendsFromDto($dto));
    }

    protected function buildAppendsFromDto(IndexQueryDTO $dto): array
    {
        return [
            // Mantém seu padrão (framework-friendly)
            'perPage' => $dto->perPage,
            'page'    => $dto->page,
            'sortBy'  => $dto->sortBy,
            'sortDir' => $dto->sortDir,
            'with'    => $dto->with,
            'filters' => $dto->filters,
        ];
    }

    public function findById(int|string $id, array $with = []): ?Model
    {
        $q = $this->with($with);
        return $q->find($id);
    }

    public function firstOrFailById(int|string $id, array $with = []): Model
    {
        $q = $this->with($with);
        return $q->findOrFail($id);
    }

    public function findManyByIds(array $ids, array $with = []): Collection
    {
        $q = $this->with($with);
        return $q->whereIn($this->model->getKeyName(), $ids)->get();
    }

    /**
     *  SAFE: valida colunas e operadores
     */
    public function exists(array $where): bool
    {
        $q = $this->query();
        $q = $this->applyWhereSafe($q, $where);
        return $q->exists();
    }

    /**
     *  SAFE: valida colunas e operadores
     */
    public function count(array $where = []): int
    {
        $q = $this->query();
        $q = $this->applyWhereSafe($q, $where);
        return (int) $q->count();
    }

    public function create(array $data): Model
    {
        $this->stampUserId($data);

        return DB::transaction(function () use ($data) {
            $model = $this->model->newInstance();
            $model->fill($data);
            $model->save();

            return $model->fresh();
        });
    }

    public function update(int|string $id, array $data): Model
    {
        $this->stampUserId($data);

        return DB::transaction(function () use ($id, $data) {
            $q = $this->query();

            if ($this->useLockForUpdateOnUpdate) {
                $q->lockForUpdate();
            }

            /** @var Model $model */
            $model = $q->findOrFail($id);

            $model->fill($data);
            $model->save();

            return $model->fresh();
        });
    }

    public function upsert(array $rows, array $uniqueBy, array $updateColumns = []): void
    {
        DB::table($this->model->getTable())->upsert($rows, $uniqueBy, $updateColumns);
    }

    public function delete(int|string $id): bool
    {
        $model = $this->query()->findOrFail($id);
        return (bool) $model->delete();
    }

    public function forceDelete(int|string $id): bool
    {
        $model = $this->withTrashedIfSupported()->findOrFail($id);

        if ($this->modelUsesSoftDeletes()) {
            return (bool) $model->forceDelete();
        }

        return (bool) $model->delete();
    }

    public function restore(int|string $id): bool
    {
        $model = $this->withTrashedIfSupported()->findOrFail($id);

        if ($this->modelUsesSoftDeletes()) {
            return (bool) $model->restore();
        }

        return false;
    }

    public function bulkDelete(array $ids): int
    {
        return $this->query()
            ->whereIn($this->model->getKeyName(), $ids)
            ->delete();
    }

    public function bulkForceDelete(array $ids): int
    {
        $q = $this->withTrashedIfSupported()
            ->whereIn($this->model->getKeyName(), $ids);

        if ($this->modelUsesSoftDeletes()) {
            return $q->forceDelete();
        }

        return $q->delete();
    }

    public function bulkRestore(array $ids): int
    {
        if (!$this->modelUsesSoftDeletes()) {
            return 0;
        }

        return $this->withTrashedIfSupported()
            ->whereIn($this->model->getKeyName(), $ids)
            ->restore();
    }

    protected function withTrashedIfSupported(): Builder
    {
        $q = $this->query();

        if ($this->modelUsesSoftDeletes()) {
            $q->withTrashed();
        }

        return $q;
    }

    protected function modelUsesSoftDeletes(): bool
    {
        return in_array(SoftDeletes::class, class_uses_recursive($this->model), true);
    }

    /**
     *  Ajustado: só aplica filtros permitidos (coluna existe / allowedFilters / filterMap).
     */
    public function applyFilters(Builder $q, array $filters): Builder
    {
        // 1) filterMap tem prioridade (campo virtual / lógica custom)
        if (property_exists($this->model, 'filterMap') && is_array($this->model->filterMap)) {
            foreach ($this->model->filterMap as $key => $callback) {
                if (array_key_exists($key, $filters) && is_callable($callback)) {
                    $q = $callback($q, $filters[$key]);
                    unset($filters[$key]);
                }
            }
        }

        // 2) valida as colunas reais
        foreach ($filters as $key => $value) {
            if ($value === null || $value === '') {
                continue;
            }

            $col = $this->resolveFilterColumn((string) $key);
            if ($col === null) {
                continue; // strictQuery pode lançar
            }

            if (is_array($value) && array_key_exists('like', $value)) {
                $like = (string) $value['like'];
                if ($like !== '') {
                    $q->where($col, 'like', '%' . $like . '%');
                }
                continue;
            }

            if (is_array($value) && array_key_exists('in', $value)) {
                $in = array_values(array_filter((array) $value['in'], fn($v) => $v !== null && $v !== ''));
                if (!empty($in)) {
                    $q->whereIn($col, $in);
                }
                continue;
            }

            if (is_array($value) && array_key_exists('between', $value)) {
                [$from, $to] = Arr::wrap($value['between']) + [null, null];
                if ($from !== null && $to !== null) {
                    $q->whereBetween($col, [$from, $to]);
                }
                continue;
            }

            if (is_bool($value)) {
                $q->where($col, $value);
                continue;
            }

            $q->where($col, $value);
        }

        return $q;
    }

    protected function stampUserId(array &$data, ?string $guard = null): void
    {
        if (!array_key_exists('user_id', $data) && $this->hasUserIdColumn()) {
            $userId = $guard ? Auth::guard($guard)->id() : Auth::id();

            if ($userId) {
                $data['user_id'] = $userId;
            }
        }
    }

    protected function hasUserIdColumn(): bool
    {
        $table = $this->model->getTable();
        return Schema::hasColumn($table, 'user_id');
    }

    /**
     * ============================
     *  SAFE WHERE (exists/count)
     * ============================
     */
    protected function applyWhereSafe(Builder $q, array $where): Builder
    {
        foreach ($where as $key => $value) {
            if ($value === null || $value === '') {
                continue;
            }

            $col = $this->resolveFilterColumn((string) $key);
            if ($col === null) {
                continue; // strictQuery pode lançar
            }

            if (!is_array($value)) {
                $q->where($col, $value);
                continue;
            }

            $op = strtolower((string) ($value['op'] ?? '='));
            $allowedOps = ['=', '!=', '<>', '>', '>=', '<', '<=', 'like', 'in', 'between', 'null', 'notnull'];

            if (!in_array($op, $allowedOps, true)) {
                $this->invalidQueryKey('where.op', (string) $op);
                continue;
            }

            if ($op === 'null') {
                $q->whereNull($col);
                continue;
            }

            if ($op === 'notnull') {
                $q->whereNotNull($col);
                continue;
            }

            if ($op === 'like') {
                $v = $value['value'] ?? null;
                if ($v !== null && $v !== '') {
                    $q->where($col, 'like', '%' . (string) $v . '%');
                }
                continue;
            }

            if ($op === 'in') {
                $vals = array_values(array_filter((array) ($value['value'] ?? []), fn($v) => $v !== null && $v !== ''));
                if (!empty($vals)) {
                    $q->whereIn($col, $vals);
                }
                continue;
            }

            if ($op === 'between') {
                [$from, $to] = Arr::wrap($value['value'] ?? null) + [null, null];
                if ($from !== null && $to !== null) {
                    $q->whereBetween($col, [$from, $to]);
                }
                continue;
            }

            $val = $value['value'] ?? null;
            if ($val === null) {
                continue;
            }

            $q->where($col, $op, $val);
        }

        return $q;
    }

    /**
     * ============================
     *  Helpers “DTO friendly”
     * ============================
     */

    protected function allowedRelations(array $fallback): array
    {
        return property_exists($this->model, 'allowedRelations')
            ? array_values((array) $this->model->allowedRelations)
            : $fallback;
    }

    protected function resolveSortColumn(string $sortBy): ?string
    {
        $allowedSorts = property_exists($this->model, 'allowedSorts')
            ? (array) $this->model->allowedSorts
            : [];

        if (!empty($allowedSorts)) {
            if (!in_array($sortBy, $allowedSorts, true)) {
                return $this->invalidQueryKey('sortBy', $sortBy);
            }
            return $sortBy;
        }

        return $this->resolveColumnIfExists($sortBy, 'sortBy');
    }

    protected function resolveFilterColumn(string $key): ?string
    {
        $allowedFilters = property_exists($this->model, 'allowedFilters')
            ? (array) $this->model->allowedFilters
            : [];

        if (!empty($allowedFilters) && !in_array($key, $allowedFilters, true)) {
            return $this->invalidQueryKey('filter', $key);
        }

        return $this->resolveColumnIfExists($key, 'filter');
    }

    protected function resolveColumnIfExists(string $col, string $context): ?string
    {
        $table = $this->model->getTable();

        if (!Schema::hasColumn($table, $col)) {
            return $this->invalidQueryKey($context, $col);
        }

        return $col;
    }

    protected function invalidQueryKey(string $context, string $key): ?string
    {
        if ($this->strictQuery) {
            throw new \InvalidArgumentException("Invalid {$context}: {$key}");
        }

        return null;
    }
}
