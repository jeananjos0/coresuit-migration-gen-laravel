<?php

namespace App\Services\Shared;

use App\DTOs\Shared\IndexQueryDTO;
use App\DTOs\Shared\PageDTO;
use App\Mappers\Contracts\ICrudMapper;
use App\Repositories\Contracts\IBaseRepository;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\Log;
use Illuminate\Pagination\LengthAwarePaginator;

/**
 * @template TModel of Model
 * @template TListDTO
 * @template TDetailDTO
 * @template TCreateDTO of object
 * @template TUpdateDTO of object
 */
abstract class BaseService implements IBaseService
{
    public function __construct(
        protected IBaseRepository $repo,
        protected ICrudMapper $mapper,
        protected string $createDtoClass,
        protected string $updateDtoClass,
    ) {}

    /* ============================================================
     | GET ALL
     ============================================================ */
    public function getAll(IndexQueryDTO $dto): PageDTO
    {
        try {
            $this->beforeGetAllDTO($dto);

            $paginator = $this->repo->getAll($dto);

            $page = $this->toPageDTO($paginator);

            $this->afterGetAllDTO($dto, $page);

            return $page;
        } catch (\Throwable $e) {
            // Log com contexto útil
            Log::error(static::class . '::getAll', [
                'dto' => [
                    'perPage' => $dto->perPage,
                    'page' => $dto->page,
                    'sortBy' => $dto->sortBy,
                    'sortDir' => $dto->sortDir,
                    'with' => $dto->with,
                    'filters' => $dto->filters,
                ],
                'ex' => $e,
            ]);

            //  não mascara bug: deixa o Handler transformar em 500
            throw $e;
        }
    }


    /* ============================================================
     | GET BY ID
     ============================================================ */
    public function getById(int|string $id, array $with = []): mixed
    {
        try {
            $this->beforeGetByIdDTO($id, $with);

            $model = $this->repo->findById($id, $with);
            if (!$model) {
                return null;
            }

            $dto = $this->mapper->toDetailDTO($model);

            $this->afterGetByIdDTO($id, $dto);

            return $this->finalizeDto($dto);
        } catch (\Throwable $e) {
            Log::warning(static::class . '::getById', ['id' => $id, 'ex' => $e]);
            return null;
        }
    }

    /* ============================================================
     | CREATE
     ============================================================ */
    public function create(object $dto): mixed
    {
        $dto = $this->assertDto($dto, $this->createDtoClass, 'Create');

        try {
            $this->beforeCreateDTO($dto);

            $payload = $this->dtoToArray($dto);

            $model = $this->repo->create($payload);

            $this->afterCreateModel($model, $dto);

            $detail = $this->mapper->toDetailDTO($model);

            $this->afterCreateDTO($dto, $detail);

            return $this->finalizeDto($detail);
        } catch (\Throwable $e) {
            Log::error(static::class . '::create', ['ex' => $e]);
            throw $e;
        }
    }

    /* ============================================================
     | UPDATE
     ============================================================ */
    public function update(int|string $id, object $dto): mixed
    {
        $dto = $this->assertDto($dto, $this->updateDtoClass, 'Update');

        try {
            $this->beforeUpdateDTO($id, $dto);

            $payload = $this->dtoToArray($dto);

            $model = $this->repo->update($id, $payload);

            $this->afterUpdateModel($model, $dto);

            $detail = $this->mapper->toDetailDTO($model);

            $this->afterUpdateDTO($id, $dto, $detail);

            return $this->finalizeDto($detail);
        } catch (\Throwable $e) {
            Log::error(static::class . '::update', ['id' => $id, 'ex' => $e]);
            throw $e;
        }
    }

    /* ============================================================
     | DELETE / RESTORE
     ============================================================ */
    public function delete(int|string $id): bool
    {
        $this->beforeDeleteDTO($id);
        $ok = $this->repo->delete($id);
        $this->afterDeleteDTO($id, $ok);
        return $ok;
    }

    public function restore(int|string $id): bool
    {
        $this->beforeRestoreDTO($id);
        $ok = $this->repo->restore($id);
        $this->afterRestoreDTO($id, $ok);
        return $ok;
    }

    public function forceDelete(int|string $id): bool
    {
        $this->beforeForceDeleteDTO($id);
        $ok = $this->repo->forceDelete($id);
        $this->afterForceDeleteDTO($id, $ok);
        return $ok;
    }

    public function deactivate(int|string $id): bool
    {
        return $this->delete($id);
    }

    public function activate(int|string $id): bool
    {
        return $this->restore($id);
    }

    /* ============================================================
     | BULK
     ============================================================ */
    public function bulkDelete(array $ids): int
    {
        $this->beforeBulkDeleteDTO($ids);
        $count = $this->repo->bulkDelete($ids);
        $this->afterBulkDeleteDTO($ids, $count);
        return $count;
    }

    public function bulkForceDelete(array $ids): int
    {
        $this->beforeBulkForceDeleteDTO($ids);
        $count = $this->repo->bulkForceDelete($ids);
        $this->afterBulkForceDeleteDTO($ids, $count);
        return $count;
    }

    public function bulkRestore(array $ids): int
    {
        $this->beforeBulkRestoreDTO($ids);
        $count = $this->repo->bulkRestore($ids);
        $this->afterBulkRestoreDTO($ids, $count);
        return $count;
    }

    protected function toPageDTO(LengthAwarePaginator $paginator): PageDTO
    {
        return new PageDTO(
            data: array_map(
                fn($item) => $this->finalizeDto(
                    $this->mapper->toListItemDTO($item)
                ),
                $paginator->items()
            ),
            currentPage: max(0, $paginator->currentPage() - 1), // frontend 0-based
            totalPages: $paginator->lastPage(),
            pageSize: $paginator->perPage(),
            totalCount: $paginator->total()
        );
    }

    /* ============================================================
     | EXISTS / COUNT   (faltavam no contrato)
     ============================================================ */
    public function exists(array $where): bool
    {
        try {
            return $this->repo->exists($where);
        } catch (\Throwable $e) {
            Log::warning(static::class . '::exists', ['where' => $where, 'ex' => $e]);
            return false;
        }
    }

    public function count(array $where = []): int
    {
        try {
            return $this->repo->count($where);
        } catch (\Throwable $e) {
            Log::warning(static::class . '::count', ['where' => $where, 'ex' => $e]);
            return 0;
        }
    }

    /* ============================================================
     | Helpers
     ============================================================ */

    protected function dtoToArray(object $dto): array
    {
        if (!method_exists($dto, 'toArray')) {
            throw new \InvalidArgumentException(
                sprintf('DTO %s must implement toArray()', get_class($dto))
            );
        }

        return $dto->toArray();
    }

    protected function assertDto(object $dto, string $expected, string $label): object
    {
        if (!$dto instanceof $expected) {
            throw new \InvalidArgumentException(
                sprintf('Invalid %s DTO. Expected %s, got %s', $label, $expected, get_class($dto))
            );
        }

        return $dto;
    }

    protected function finalizeDto(mixed $dto): mixed
    {
        return is_object($dto) && method_exists($dto, 'toArray')
            ? $dto->toArray()
            : $dto;
    }

    /* ============================================================
     | HOOKS (DTO-only)
     ============================================================ */

    protected function beforeGetAllDTO(IndexQueryDTO $dto): void {}
    protected function afterGetAllDTO(IndexQueryDTO $dto, PageDTO $page): void {}

    protected function beforeGetByIdDTO(int|string $id, array $with): void {}
    protected function afterGetByIdDTO(int|string $id, object $detailDto): void {}

    protected function beforeCreateDTO(object $dto): void {}
    protected function afterCreateModel(Model $model, object $dto): void {}
    protected function afterCreateDTO(object $dto, object $detailDto): void {}

    protected function beforeUpdateDTO(int|string $id, object $dto): void {}
    protected function afterUpdateModel(Model $model, object $dto): void {}
    protected function afterUpdateDTO(int|string $id, object $dto, object $detailDto): void {}

    protected function beforeDeleteDTO(int|string $id): void {}
    protected function afterDeleteDTO(int|string $id, bool $ok): void {}

    protected function beforeRestoreDTO(int|string $id): void {}
    protected function afterRestoreDTO(int|string $id, bool $ok): void {}

    protected function beforeForceDeleteDTO(int|string $id): void {}
    protected function afterForceDeleteDTO(int|string $id, bool $ok): void {}

    protected function beforeBulkDeleteDTO(array $ids): void {}
    protected function afterBulkDeleteDTO(array $ids, int $count): void {}

    protected function beforeBulkForceDeleteDTO(array $ids): void {}
    protected function afterBulkForceDeleteDTO(array $ids, int $count): void {}

    protected function beforeBulkRestoreDTO(array $ids): void {}
    protected function afterBulkRestoreDTO(array $ids, int $count): void {}
}
